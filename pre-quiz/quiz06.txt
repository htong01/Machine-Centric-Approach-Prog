# 1.
If we have the declaration:
  char part[] = "radiator"

What is the length of the `part` array (in bytes)?

(integer) ---
8

# 2.
If we have the declarations:
  char castiron[] = "My cast iron skillet";
  char pan[5];

Which of the following are valid ways to copy the string (i.e., succeed in copying as much of the string as possible, and don't cause something bad to happen)?

(select all that apply) ---
[ F] pan = castiron;
[ T] *pan = *castiron;
[ ] &pan = &castiron;
[ ] strcmp(pan, castiron);
[ ] strcpy(pan, castiron);
[ T] strncpy(pan, castiron, 5);

# 3.
Which of these are valid declarations of functions taking muldimensional arrays?

(select all that apply) ---
[ T] saute(int x[2][2])
[ T] deepfry(int x[][2])
[ ] braise(int x[2][])
[ T] bake(int x[][2][3])
[ ] grill(int x[2][5][])

# 4.
Why would you use an array of pointers to arrays instead of a 2D array?

(select all that apply) ---
[ T] Accessing elements is faster because of pointer dereferencing.
[ ] The arrays can be different sizes, instead of all the same.
[ ] The arrays can hold different types of data, without the need to cast.
[ T] It allows us to rearrange the "matrix" just by manipulating pointers.

# 5.
What are two examples the book gives for why function pointers are useful?
(string) ---
To make a function pointer as a parameter to function, the first example is passing in a function pointer for the parameter that specifies "what to do to each item".
The second example is in generic sorting function, to sort any type of data. 
# 6.
What questions do you have about the material in this chapter?
(string) ---


# 7.
What concepts would you most like to review in class?
(string) ---


